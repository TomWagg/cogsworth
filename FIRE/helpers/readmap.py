import numpy as np
import h5py
import os.path
import timeit as tm

def readmap(mdir, mnum, res, mask='', maskValue = 0, header_info=0, loud=0):
    #####
    # readmap function:
    #
    # Purpose: load datasets in maps generated by FIREMapper
    #
    # Inputs/flags:
    # mdir - directory that maps are in, can be a list (i.e., multiple galaxies)
    # mnum - snapshot/map numbers, usually a list/iterable
    # res - map pixel size, in pc [type==int].
    # mask - 'gas' or 'stars' give pixels with GasMass or StarMass > 0, respectively.
    #   can also supply ANY(!) key, or list of keys for masking (AND mask for all keys together
    #   e.g., ['GasMass', 'StarMass'] makes a mask of pixels with GasMass>0 & StarMask>0.
    # maskValue - value for masking (gtr than), defaults to zero.  Supply either an equal
    #   length list of values if mask is a list, or a single value for all maskKeys
    # header_info - return arrays with header info for each pixel (e.g., array of run names)
    bigtoc = tm.default_timer()
    if type(mdir)==str: mdir = [mdir] # sanitize mdir input to be iterable
    if type(mnum)==int: mnum = [mnum] # sanitize mnum input to be iterable
    
    # Figure out what fields are contained in the maps:
    mm = str(mnum[0])
    if mnum[0]<100: mm='0'+mm
    rr = str(res)
    if res<100:
        #rr = str(res)
        rr='0'+rr
    mapzero = mdir[0]+'/map_'+mm+'_'+rr+'pc.hdf5'
    try:
        file = h5py.File(mapzero,'r')
    except:
        print("Error: Failed to read key (first) map! I'm having a breakdown.")
        return {'k':-1}
    keys = list(file.keys()) # keys to the data fields
    hdr_keys = list(file.attrs.keys()) # get the header attribs here too
    nx = int(file.attrs['Nx'])**2 # pixels in each map.. field should be in the attrs.
    toc = tm.default_timer()
    # Construct array for radius (in kpc) of pixels
    rads = np.arange(0, nx)
    cent = float(int(res / 1000. * nx ** 0.5)) / 2  # ; print cent
    for i in range(0, nx):
        rads[i] = (((np.floor(rads[i] / nx ** 0.5) * res / 1000. + res / 2000.) - cent) ** 2\
                   + (((rads[i] % nx ** 0.5) * res / 1000. + res / 2000.) - cent) ** 2) ** 0.5
            # radius of pixel from core, in kpc
    rads = np.array(rads)
    tic = tm.default_timer()
    if loud: print("Calculated radius points in %.2f sec!" % (tic - toc))
    toc = tm.default_timer()
    dataset={} # init dataset dict w/ none
    keyshapes = [ [] for i in range(len(keys))]
    if loud: print("Number of keys in dataset: "+str(len(keys)))
    kk = 0
    for key in keys:
        nx_tot_guess = int(len(mdir) * len(mnum) * nx)  # guess how big the final datasets have to be.
        # Init dict to max size (and dims) for all keys
        keyshapes[kk] = file[key].shape
        if len(keyshapes[kk])==3:
            dataset[key] = np.zeros((nx_tot_guess,keyshapes[kk][2]))
        elif len(keyshapes[kk])==2:
            dataset[key] = np.zeros(nx_tot_guess)
        else:
            print("Error: Datasets are a weird shape (i.e., NOT (nx, nx, N) ).")
            return {'k':-1}
        kk += 1
    
    dataset['R'] = np.zeros(nx_tot_guess) # manually make a Radius dataset
    dataset['z'] = np.zeros(nx_tot_guess) # manually make a redshift dataset
    dataset['SnapNum'] = np.zeros(nx_tot_guess) # manually make a SnapNum dataset
    dataset['RunName'] = np.empty((nx_tot_guess,), dtype=object)
    file.close()

    tic = tm.default_timer()
    if loud: print("Initialized dataset in %.2f sec!" % (tic - toc))
    toc = tm.default_timer()
    # Load the maps!
    nL = 0
    for gal in mdir:
        if loud: print("Loading: "+gal)
        for ii in mnum:
            mapfile = gal+'/map_'+str(ii)+'_'+rr+'pc.hdf5'
            try:
                file = h5py.File(mapfile,'r')
            except:
                print("Warning: Failed to load "+mapfile)
                continue
            dataset['R'][nL:nL+nx] = rads
            dataset['z'][nL:nL+nx] = file.attrs['Redshift']
            dataset['SnapNum'][nL:nL+nx] = ii
            RunNameStr = file.attrs['RunName']
            dataset['RunName'][nL:nL+nx] = RunNameStr
            kk = 0
            for key in keys:
                if len(keyshapes[kk]) == 3:
                    dataset[key][nL:nL+nx,:] = np.reshape(file[key],(nx,keyshapes[kk][2]))
                else: dataset[key][nL:nL+nx] = np.ravel(file[key]) #np.reshape(file[key],nx)
                kk += 1
            nL += nx
            file.close()
    keys += ['R','z','SnapNum','RunName'] # make sure the keys array has radius/redshift/runname in it for masking..
    tic = tm.default_timer()
    if loud: print("Loaded dataset in %.2f sec!" % (tic - toc))

    # Trim unused pixels
    toc = tm.default_timer()
    nonemptymask = (dataset['RunName'] != '')
    emptypixels = len(dataset['RunName'][dataset['RunName'] == ''])
    if emptypixels:
        for key in keys:
            if len(dataset[key].shape) == 2:
                dataset[key] = dataset[key][nonemptymask]
            else: dataset[key] = dataset[key][nonemptymask]
    tic = tm.default_timer()
    if loud and emptypixels: print("Trimmed "+str(emptypixels)+" empty pixels in %.2f sec!" % (tic - toc))
    # Mask the datasets:
    # Sanitize inputs -
    toc = tm.default_timer()
    if (mask=='gas') or (mask=='Gas') or (mask=='GAS'): mask = ['GasMass']
    if (mask=='stars') or (mask=='Stars') or (mask=='STARS') or (mask=='star') or (mask=='Star') or (mask=='STAR'): mask = ['StarMass']
    if type(mask)==str: maskKeys = [mask]
    elif type(mask)==list: maskKeys = mask
    else:
        print("Error: mask must be either a string or list of strings.")
        return {'k':-1}
    if (type(maskValue)==int) or (type(maskValue)==float): maskValues = [maskValue]
    elif type(maskValue)==list: maskValues=maskValue
    else:
        print("Error: maskValue must be either an int/float or a list of ints/floats.")
        return {'k':-1}
    if (len(maskValues)==1)&(len(maskKeys)>1):
        print("Assuming single maskValue for all maskKeys...")
        maskValues = [maskValue for ii in range(len(maskKeys))]
    elif (len(maskValues)>len(maskKeys)):
        print("Warning: more maskValues than maskKeys, check your inputs!")
    elif (len(maskValues)<len(maskKeys)):
        maskValues.extend([0 for ii in range(len(maskKeys)-len(maskValues))])
        print("Warning: more maskKeys than maskValues, check your inputs (assuming 0 for nondefined values)!")

    ###
    if all([maskKey in keys for maskKey in maskKeys]): #check that all mask fields actually exist
        if loud:
            print("Masking dataset...")
            print("Pixels must have "+maskKeys[0]+" > "+str(maskValues[0]))
        maskArray = dataset[maskKeys[0]]>maskValues[0]
        if len(maskKeys)>1:
            maskValue_ii = 1
            for maskKey in maskKeys[1:]:
                maskArray = maskArray & (dataset[maskKey]>maskValues[maskValue_ii])
                print("...and "+maskKey+" > "+str(maskValues[maskValue_ii]))
                maskValue_ii += 1

        if loud: print("Pixels in cut: "+str(len(dataset[maskKey][maskArray])))
        for key in keys:
            if len(dataset[key].shape) == 2:
                dataset[key] = dataset[key][maskArray]
            else: dataset[key] = dataset[key][maskArray]
        tic = tm.default_timer()
        if loud: print("Masking done in %.2f sec!" % (tic - toc))
    else:
        if loud:
            tic = tm.default_timer()
            print("No masking applied to dataset. (%.2f sec)" % (tic - toc))
            print("Pixels in dataset: "+str(len(dataset[key])))

    dataset['k'] = 1
    bigtic = tm.default_timer()
    if loud: print("readmap total runtime: %.2f sec!" % (bigtic - bigtoc))

    return dataset
